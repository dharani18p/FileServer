intersection

class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> set1=new HashSet<>();
        HashSet<Integer> resSet=new HashSet<>();
        for(int num:nums1){
            set1.add(num);
        }
        for(int num:nums2){
            if(set1.contains(num)){
                resSet.add(num);
            }
        }
        int[] res = new int[resSet.size()];
        Integer[] temp = resSet.toArray(new Integer[0]);

         for (int i = 0; i < temp.length; i++) {
            res[i] = temp[i];
        }
        return res;

    }
}
##
subarraySum

class Solution {
    public int subarraySum(int[] nums, int k) {
        int sum=0;int c=0;
        HashMap<Integer,Integer> map=new HashMap<>();
        map.put(0,1);
        for(int num:nums){
            sum+=num;
            if(map.containsKey(sum-k)){
                c+=map.get(sum-k);
            }
        map.put(sum,map.getOrDefault(sum,0)+1);

        }
        return c;
        
    }
}
##
minPatches

 class Solution {
    public int minPatches(int[] nums, int n) {
        long miss=1;int i=0;
        int patch=0;
        while(miss<=n){
            if(i<nums.length&&nums[i]<=miss){
                 miss+=nums[i];
                 i++;
            }
            else{
                patch++;

                miss=2*miss;
                }


        }
        return patch;
    }
}
##
countSubarrays

class Solution {
    public long countSubarrays(int[] nums, long k) {
        long count = 0;
        long sum = 0;
        int left = 0;

        for (int right = 0; right < nums.length; right++) {
            sum += nums[right];
            
            while (sum * (right - left + 1) >= k) {
                sum -= nums[left];
                left++;
            }

            count += (right - left + 1);
        }

        return count;
    }
}
##
numRescueBoats

import java.util.Arrays;

class Solution {
    public int numRescueBoats(int[] people, int limit) {
        Arrays.sort(people);  
        int l = 0;
        int r = people.length - 1;
        int boats = 0;

        while (l <=r) {
            if (people[l] + people[r] <= limit) {
                l++;
            }
            r--;
            boats++;
        }

        return boats;
    }
}
##
twoSum

class Solution {
    public int[] twoSum(int[] nums, int target) {
        int first=0;

        int sec=0;
        for(int k=0;k<nums.length;k++){
            for(int j=k+1;j<nums.length;j++){
            if(nums[k]+nums[j]==target){
                first=k;
                sec=j;
            }

        }
        }
        return new int[]{first,sec};
    
    
}
}
##
maxSlidingWindow
import java.util.*;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k <= 0) return new int[0];

        int n = nums.length;
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();

        for (int i = 0; i < n; i++) {
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1)
                deque.pollFirst();

            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i])
                deque.pollLast();

            deque.offerLast(i); 

            if (i >= k - 1)
                result[i - k + 1] = nums[deque.peekFirst()];
        }

        return result;
    }
}
##
threeSumClosest
import java.util.*;

class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        int closest = nums[0] + nums[1] + nums[2];
        
        for (int i = 0; i < nums.length - 2; i++) {
            int left = i + 1, right = nums.length - 1;
            
            while (left < right) {
                int sum = nums[i] + nums[left] + nums[right];
                
                if (Math.abs(sum - target) < Math.abs(closest - target)) {
                    closest = sum;
                }
                
                if (sum < target) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        
        return closest;
    }
}
##
missingNumber
class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int expectedSum = n * (n + 1) / 2;
        int actualSum = 0;
        
        for (int num : nums) {
            actualSum += num;
        }
        
        return expectedSum - actualSum;
    }
}
##
maxEnvelopes

import java.util.*;

public class Main {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputLine = scanner.nextLine().trim();

        // Clean up input string and parse it
        inputLine = inputLine.replaceAll("\\[\\[", "").replaceAll("]]", "");
        String[] pairStrings = inputLine.split("\\],\\[");

        int[][] envelopes = new int[pairStrings.length][2];
        for (int i = 0; i < pairStrings.length; i++) {
            String[] nums = pairStrings[i].split(",");
            envelopes[i][0] = Integer.parseInt(nums[0].trim());
            envelopes[i][1] = Integer.parseInt(nums[1].trim());
        }

        Solution solution = new Solution();
        int result = solution.maxEnvelopes(envelopes);
        System.out.println(result);
    }
}
class Solution {

    public int maxEnvelopes(int[][] nums) {
       Arrays.sort(nums,(a,b)->{
           if (a[0]==b[0]){
               return b[1]-a[1];
           }
           return a[0]-b[0];
       });
       int n=nums.length;
       int height[] =new int[n+1];
       height[1]=nums[0][1];
       int cnt=1;
       for(int i=1;i<n;i++){
           if(height[cnt]<nums[i][1]){
               cnt++;
               height[cnt]=nums[i][1];
           }
           else{
               int l=0,h=cnt;
               while(l<h){
                   int m=(l+h)/2;
                   if(height[m]<nums[i][1]) l=m+1;
                   h=m;
               }
               int p=1;
               if(height[p]<nums[i][1]){
                   p=l;
                   height[p]=nums[i][1];
               }
           }
       }
       return cnt;
    }
}

##
findMinArrowShots

import java.util.*;

class Solution {
    public int findMinArrowShots(int[][] points) {
        if (points.length == 0) return 0;
        
        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));
        
        int arrows = 1;
        int end = points[0][1];
        
        for (int i = 1; i < points.length; i++) {
            if (points[i][0] > end) {
                arrows++;
                end = points[i][1];
            }
        }
        
        return arrows;
    }
}
##
firstUniqChar

class Solution {
    public int firstUniqChar(String s) {
        int[] count = new int[26];
        
        for (char c : s.toCharArray()) {
            count[c - 'a']++;
        }
        
        for (int i = 0; i < s.length(); i++) {
            if (count[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }
        
        return -1;
    }
}
##
easy5
class Solution {
    public int numJewelsInStones(String jewels, String stones) {
        int count=0;
        for(char a:stones.toCharArray()){
            if(jewels.indexOf(a)!=-1){
                count++;
            }
        }
        return count;

        
    }
}
##
mid5
class Solution {
    public String findLongestWord(String s, List<String> dictionary) {
        String longest = "";

        for (String word : dictionary) {
            if (word.length() < longest.length() ||
                (word.length() == longest.length() && word.compareTo(longest) > 0)) {
                continue;
            }

            int pos = -1;
            boolean isSubsequence = true;

            for (int i = 0; i < word.length(); i++) {
                pos = s.indexOf(word.charAt(i), pos + 1);
                if (pos == -1) {
                    isSubsequence = false;
                    break;
                }
            }

            if (isSubsequence) {
                longest = word;
            }
        }

        return longest;
    }
}
##
hard5
class Solution {
    public String shortestPalindrome(String s) {
        String rev = new StringBuilder(s).reverse().toString();
        for (int i = 0; i < s.length(); i++) {
            if (s.startsWith(rev.substring(i))) {
                return rev.substring(0, i) + s;
            }
        }
        return "";
    }
}

##
easy6
import java.util.*;

public class Solution {

    public boolean checkIfExist(int[] arr) {
       for(int i=0;i<arr.length;i++)
       {
           for(int j=0;j<arr.length;j++){
               if(arr[i]==arr[j]*2)return true;
           }
       }
       return false;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        // Read the entire line as input
        int n = scanner.nextInt();
        int[] arr = new int[n];

        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        boolean result = sol.checkIfExist(arr);
        System.out.println(result);
    }
}
##
mid6
import java.util.*;

public class Solution
{
    public String decodeString(String s)
    {
        String res="";
        int i=0;
        Stack<Character> st=new Stack<>();
        Stack<Integer> inst=new Stack<>();
        int num=0;
        while (i<s.length()){
            
            if(s.charAt(i)=='['){
                inst.push(num);
                st.push(s.charAt(i));
                num=0;
            }
            else if(s.charAt(i)-'0'>=0 && s.charAt(i)-'0'<=9){
                num=num*10+s.charAt(i)-'0';
            }
            else if(s.charAt(i)==']'){
                String c="";
                int current;
                String cur="";
                while (st.isEmpty()==false && st.peek()!='['){
                    cur=String.valueOf(st.pop())+cur;
                }
                if (!st.isEmpty()) st.pop(); 
                current = inst.isEmpty() ? 1 : inst.pop(); 
                for(int j=0;j<current;j++){
                    c+=cur;
                }
                for (int j = 0; j < c.length(); j++) {
                    st.push(c.charAt(j));
                }
                
            }
            else {
                st.push(s.charAt(i));
            }
            i++;
        }
        while (!st.isEmpty()) {
            res = st.pop() + res;
        }
        return res;      
      
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String input = scanner.nextLine();

        Solution solution = new Solution();
        String result = solution.decodeString(input);
        System.out.println( result);

        scanner.close();
    }
}
##
hard6
class Solution {
    public List<String> fullJustify(String[] words, int maxWidth) {
        List<String> result = new ArrayList<>();
        int index = 0;

        while (index < words.length) {
            int totalChars = words[index].length();
            int last = index + 1;

            // Determine how many words fit into the current line
            while (last < words.length) {
                if (totalChars + 1 + words[last].length() > maxWidth) break;
                totalChars += 1 + words[last].length();
                last++;
            }

            StringBuilder sb = new StringBuilder();
            int numberOfWords = last - index;
            int numberOfGaps = numberOfWords - 1;

            // If it's the last line or only one word fits, left-justify
            if (last == words.length || numberOfWords == 1) {
                for (int i = index; i < last; i++) {
                    sb.append(words[i]);
                    if (i < last - 1) sb.append(" ");
                }
                while (sb.length() < maxWidth) {
                    sb.append(" ");
                }
            } else {
                int totalSpaces = maxWidth - (totalChars - numberOfGaps);
                int spacePerGap = totalSpaces / numberOfGaps;
                int extraSpaces = totalSpaces % numberOfGaps;

                for (int i = index; i < last; i++) {
                    sb.append(words[i]);
                    if (i < last - 1) {
                        int spacesToAdd = spacePerGap + (extraSpaces-- > 0 ? 1 : 0);
                        for (int s = 0; s < spacesToAdd; s++) {
                            sb.append(" ");
                        }
                    }
                }
            }

            result.add(sb.toString());
            index = last;
        }

        return result;
    }
}
##
easy7
class Solution {
    public boolean isPowerOfTwo(int n) {
        return (n > 0 && (n & (n - 1)) == 0);
    }
}
##
mid7
class Solution {
    public int reverse(int x) {
         long rev=0;
        while(x!=0){

            int rem=x%10;
            rev=rev*10+rem;
            x/=10;

        }
        if(rev<Integer.MIN_VALUE||rev>Integer.MAX_VALUE){
            return 0;
        }
        return (int) rev;
    }
}
##
hard7
import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class Solution {

    // Static Node structure
    static class ListNode {
        int val;
        ListNode next;

        ListNode(int x) {
            val = x;
            next = null;
        }
    }

    // Merge k sorted linked lists
    public ListNode mergeKLists(ListNode[] lists) {
         if(lists==null || lists.length==0) return null;
         return mergek(lists,0,lists.length-1);
         
        }
    private ListNode mergek(ListNode[] lists,int st,int end){
        if(st==end) return lists[st];
        if(st+1==end) return  merge(lists[st],lists[end]);
        int m=st+(end-st)/2;
        ListNode l=mergek(lists,st,m);
        ListNode r=mergek(lists,m+1,end);
        return merge(l,r);
    }
    private ListNode merge(ListNode l1,ListNode l2){
        ListNode dummy=new ListNode(0);
        ListNode curr=dummy;
        while(l1!=null &&l2!=null){
        if(l1.val<l2.val){
            curr.next=l1;
            l1=l1.next;
        }
        else{
                curr.next=l2;
            l2=l2.next;
        }
        curr=curr.next;}
        curr.next=(l1!=null)?l1:l2;
        return dummy.next;
    }

        
    

    // Create linked list from array
    public ListNode createList(int[] values) {
        if (values.length == 0) return null;
        ListNode head = new ListNode(values[0]);
        ListNode current = head;

        for (int i = 1; i < values.length; i++) {
            current.next = new ListNode(values[i]);
            current = current.next;
        }

        return head;
    }

    // Convert a single list to LeetCode-style string
    public String listToString(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        while (head != null) {
            sb.append(head.val);
            if (head.next != null) sb.append(",");
            head = head.next;
        }
        sb.append("]");
        return sb.toString();
    }

    // Convert array of linked lists to LeetCode-style input string
    public String listsToInputString(ListNode[] lists) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        for (int i = 0; i < lists.length; i++) {
            sb.append(listToString(lists[i]));
            if (i < lists.length - 1) sb.append(",");
        }
        sb.append("]");
        return sb.toString();
    }

    // Main method
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution solution = new Solution();

        int k = scanner.nextInt(); // Number of linked lists
        ListNode[] lists = new ListNode[k];

        for (int i = 0; i < k; i++) {
            int n = scanner.nextInt(); // Number of elements in list i
            int[] values = new int[n];
            for (int j = 0; j < n; j++) {
                values[j] = scanner.nextInt();
            }
            lists[i] = solution.createList(values);
        }

        //System.out.println("Input: lists = " + solution.listsToInputString(lists));

        ListNode mergedHead = solution.mergeKLists(lists);

        System.out.println(solution.listToString(mergedHead));

        scanner.close();
    }
}
##
easy8
import java.util.LinkedList;
import java.util.Queue;

class RecentCounter {
    private Queue<Integer> queue;

    public RecentCounter() {
        queue = new LinkedList<>();
    }

    public int ping(int t) {
        queue.add(t);
        while (!queue.isEmpty() && queue.peek() < t - 3000) {
            queue.poll();
        }
        return queue.size();
    }
}

##
mid8
import java.util.Scanner;

public class Solution {

    public int primePalindrome(int n) 
    {
     if(n<=2) return 2;
     else if(n<=3) return 3; 
     else if(n<=5) return 5;
     else if(n<=7) return 7; 
     else if(n<=11) return 11; 
     while(true){
         if(n%2==0){
             n++;
             continue;
         }
         
         String s = Integer.toString(n);
         int len = s.length();
         
         if(len%2==0){
             n=(int) Math.pow(10,len);
             continue;
         }
         int temp = n, rev=0, rem;
         while(temp!=0){
             rem=temp%10;
             rev = rev*10+rem;
             temp = temp/10;
         }
         if(n==rev){
         boolean isprime = true;
         for(int i=3;i*i<=n;i+=2){
             if(n%i==0){
                 isprime=false;
                 break;
            }
                 
        }
        if(isprime){
            return n;
            
        }
     }
     n++;
     
    } 
     
     
     
    }

    boolean isPrime(int num) {
        if (num < 2) return false;
        if (num % 2 == 0 && num != 2) return false;
        for (int j = 3; j <= Math.sqrt(num); j += 2) {
            if (num % j == 0) return false;
        }
        return true;
    }

    boolean isPal(int num) {
        int original = num, r = 0;
        while (num > 0) {
            r = r * 10 + num % 10;
            num /= 10;
        }
        return original == r;
    }

    int len(int n) {
        return (int) Math.log10(n) + 1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        Solution sol = new Solution();
        int result = sol.primePalindrome(n);
        System.out.println(result);

        scanner.close();
    }
}

##
hard8
import java.util.Scanner;

public class Solution {

    public int findKthNumber(int n, int k) {
        int curr = 1;
        k = k-1;
        while(k>0){
            int count =0;
            long first = curr;
            long next = curr+1;
            while(first<=n){
                count+=Math.min(n+1,next)-first;
                first*=10;
                next*=10;
            }
            if(count<=k){
                curr++;
                k=k-count;
            }
            else{
                curr*=10;
                k=k-1;
            }
        }
        return curr;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        try {
            int n = scanner.nextInt();
            int k = scanner.nextInt();

            Solution sol = new Solution();
            int result = sol.findKthNumber(n, k);
            System.out.println(result);
        } catch (Exception e) {
            // Avoid crashing in judge environment. Print nothing or a default value.
        } finally {
            scanner.close();
        }
    }
}

##
easy9
import java.util.Scanner;
import java.util.HashMap;
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) 
{
        this.val = val;
        this.next = null;
    }
}
public class Main {
    public boolean hasCycle(ListNode head) {
        HashMap <ListNode,Boolean> Visited = new HashMap<>();
        while(head!=null){
            if(Visited.containsKey(head)){
                return true;
                
            }
            Visited.put(head,true);
            head = head.next;
        }
        return false;
        
        
    }
    public static ListNode createLinkedList(int[] values, int pos) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        ListNode cycleNode = null;

        for (int i = 0; i < values.length; i++) {
            current.next = new ListNode(values[i]);
            current = current.next;
            if (i == pos) {
                cycleNode = current;
            }
        }

        if (pos != -1) {
            current.next = cycleNode;
        }
        return dummy.next;
    }
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Main detector = new Main(); 
        int n = scanner.nextInt();
        int[] values = new int[n];
        for (int i = 0; i < n; i++) {
            values[i] = scanner.nextInt();
        }

        int pos = scanner.nextInt();
        ListNode head = createLinkedList(values, pos);
        boolean result = detector.hasCycle(head);
        System.out.println( result);
    }
}

##
mid9
import java.util.*;

class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int res = 0;
        Arrays.sort(intervals,(a,b)->a[1]-b[1]);
        int prev_end = intervals[0][1];
        for(int i= 1; i < intervals.length; i++){
            if(prev_end >intervals[i][0] ){
                res++;
            }
            else{
                prev_end = intervals[i][1];
            }
        }
        return res;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputLine = scanner.nextLine().trim();

        // Remove the outer brackets and split into individual intervals
        inputLine = inputLine.replaceAll("\\[\\[", "").replaceAll("]]", "");
        String[] intervalStrings = inputLine.split("\\],\\[");

        int[][] intervals = new int[intervalStrings.length][2];
        for (int i = 0; i < intervalStrings.length; i++) {
            String[] parts = intervalStrings[i].split(",");
            intervals[i][0] = Integer.parseInt(parts[0].trim());
            intervals[i][1] = Integer.parseInt(parts[1].trim());
        }

        Solution solution = new Solution();
        int result = solution.eraseOverlapIntervals(intervals);
        System.out.println(result);
    }
}
##
hard9
import java.util.*;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode reverseKGroup(ListNode head, int k) { 
        if(head==null) return head;
        ListNode tail=head;
        for(int i=0;i<k;i++){
            if(tail==null) return head;
            tail=tail.next;
            
        }
        ListNode nh=reverse(head,tail);
        head.next=reverseKGroup(tail,k);
        return nh;
    
    }
    ListNode reverse(ListNode curr,ListNode end){
        ListNode prev=null;
        while(curr!=end){
            ListNode next=curr.next;
            curr.next=prev;
            prev=curr;
            curr=next;
        }
        return prev;
    }

    

    public List<Integer> toList(ListNode head) {
        List<Integer> result = new ArrayList<>();
        while (head != null) {
            result.add(head.val);
            head = head.next;
        }
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution solution = new Solution();

        //System.out.println("Enter list (e.g., [1,2,3,4,5]):");
        String input = scanner.nextLine().trim();
        input = input.replaceAll("[\\[\\]\\s]", "");
        String[] parts = input.split(",");

        //System.out.print("Enter k: ");
        int k = scanner.nextInt();

        // Build linked list
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (String part : parts) {
            if (!part.isEmpty()) {
                current.next = new ListNode(Integer.parseInt(part));
                current = current.next;
            }
        }

        ListNode head = dummy.next;
        ListNode newHead = solution.reverseKGroup(head, k);

        // Print output as list
        List<Integer> result = solution.toList(newHead);
        //System.out.println("Output:");
        System.out.println(result);

        scanner.close();
    }
}
##
easy10
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) {
        val = x;
    }
}

public class AverageLevelsInBinaryTree {

    public static TreeNode buildTreeFromInput(String[] input) {
        if (input.length == 0 || input[0].equalsIgnoreCase("null"))
            return null;

        TreeNode root = new TreeNode(Integer.parseInt(input[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;

        while (i < input.length) {
            TreeNode current = queue.poll();

            if (i < input.length && !input[i].equalsIgnoreCase("null")) {
                current.left = new TreeNode(Integer.parseInt(input[i]));
                queue.offer(current.left);
            }
            i++;

            if (i < input.length && !input[i].equalsIgnoreCase("null")) {
                current.right = new TreeNode(Integer.parseInt(input[i]));
                queue.offer(current.right);
            }
            i++;
        }

        return root;
    }public static List<Double> averageOfLevels(TreeNode root)
    {
       List<Double> res=new ArrayList<>();
       if(root==null) return res;
       
       Queue<TreeNode> q=new LinkedList<>();
       q.add(root);
       
       while(!q.isEmpty()){
           int level=q.size();
           double sum=0.0;
           for(int i=0;i<level;i++){
               TreeNode curr=q.poll();
               sum+=curr.val;
               if(curr.left!=null) q.offer(curr.left);
               if(curr.right!=null) q.offer(curr.right);
           }
           res.add(sum/level);
       }
       return res;
        
        
    }
        public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();
        String[] nodes = line.trim().split("\\s+");

        TreeNode root = buildTreeFromInput(nodes);
        List<Double> averages = averageOfLevels(root);

        System.out.println("Average of each level:");
        for (double avg : averages) {
            System.out.printf("%.2f ", avg);
        }
    }
}
##
mid10
import java.util.*;

public class Solution {

    // Definition for singly-linked list.
    static class ListNode {
        int val;
        ListNode next;

        ListNode() {}

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    // Method to delete all nodes with duplicate values
    public ListNode deleteDuplicates(ListNode head) {
       ListNode temp=head; 
       ListNode prev=null;
       
       while(temp!=null){
           boolean dup=false;
           while(temp.next!=null && temp.val==temp.next.val){
               dup=true;
               temp=temp.next;
           }
           if(dup){
               if(prev==null) head=temp.next;
               else prev.next=temp.next;
           }
           else{
              prev=temp;
           }
           temp=temp.next;
       }
       return head;
    }

    // Helper: Create linked list from valid user input
    public static ListNode buildListFromInput(Scanner scanner) {
       // System.out.println("Enter sorted linked list values (space-separated integers):");
        String line = scanner.nextLine().trim();

        if (line.isEmpty()) {
            System.out.println("Empty input. Creating an empty list.");
            return null;
        }

        String[] tokens = line.split("\\s+");
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;

        for (String token : tokens) {
            try {
                int val = Integer.parseInt(token);
                current.next = new ListNode(val);
                current = current.next;
            } catch (NumberFormatException e) {
                System.out.println("Invalid input: '" + token + "' is not an integer. Skipping it.");
            }
        }

        return dummy.next;
    }

    // Helper: Print list as array format
    public static void printListAsArray(ListNode head) {
        if (head == null) {
            System.out.println("[]");
            return;
        }

        List<Integer> values = new ArrayList<>();
        while (head != null) {
            values.add(head.val);
            head = head.next;
        }

        System.out.println(values.toString());
    }

    // Main method
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution solution = new Solution();

        ListNode head = buildListFromInput(scanner);
        ListNode result = solution.deleteDuplicates(head);
        printListAsArray(result);

        scanner.close();
    }
}
##
hard10
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) {
        val = x;
    }
}

class Solution {
    int max_val = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maximum (root);
        return max_val;
    }

    private int maximum(TreeNode node) {
        if(node == null){
            return 0;
        }
        int left = Math.max(maximum(node.left),0);
        int right = Math.max(maximum(node.right),0);
        int curr = left+right+node.val;
        max_val=Math.max(max_val,curr);
        return node.val + Math.max (left,right);
    }
}

public class Main {
    public static TreeNode buildTree(String[] nodes) {
        if (nodes.length == 0 || nodes[0].equals("null")) return null;

        TreeNode root = new TreeNode(Integer.parseInt(nodes[0].trim()));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;

        while (!queue.isEmpty() && i < nodes.length) {
            TreeNode curr = queue.poll();

            if (i < nodes.length && !nodes[i].trim().equals("null")) {
                curr.left = new TreeNode(Integer.parseInt(nodes[i].trim()));
                queue.offer(curr.left);
            }
            i++;

            if (i < nodes.length && !nodes[i].trim().equals("null")) {
                curr.right = new TreeNode(Integer.parseInt(nodes[i].trim()));
                queue.offer(curr.right);
            }
            i++;
        }
        return root;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String input = sc.nextLine();
        String[] nodes = input.replaceAll("\\[|\\]", "").split(",");
        TreeNode root = buildTree(nodes);
        Solution sol = new Solution();
        int result = sol.maxPathSum(root);
        System.out.println( result);
    }
}
##
easy11
import java.util.*;

// TreeNode class for binary tree nodes
class TreeNode {
    int val;
    TreeNode left, right;

    TreeNode(int x) {
        val = x;
    }
}

// Utility class to store information from recursive calls
final class TreeInfo {
    public final int height;
    public final boolean balanced;

    public TreeInfo(int height, boolean balanced) {
        this.height = height;
        this.balanced = balanced;
    }
}

// Solution to check if a binary tree is balanced
class Solution {
    private int isBalancedTreeHelper(TreeNode root) {
        if(root==null) return 0;
        int l=isBalancedTreeHelper(root.left);
        if(l==-1) return -1;
        int r=isBalancedTreeHelper(root.right);
        if(r==-1) return -1;
        
        if(Math.abs(l-r)>1) return -1;
        return Math.max(l,r)+1;
    }
    public boolean isBalanced(TreeNode root) {
        return isBalancedTreeHelper(root)!=-1;
    }
}


public class Main{
    // Method to parse LeetCode-style input and build tree
    public static TreeNode buildTreeFromLeetCodeInput(String input) {
        input = input.trim();
        if (!input.startsWith("[") || !input.endsWith("]")) return null;
        input = input.substring(1, input.length() - 1); // remove brackets

        if (input.isEmpty()) return null;

        String[] parts = input.split(",");
        List<TreeNode> nodes = new ArrayList<>();

        for (String part : parts) {
            part = part.trim();
            if (part.equals("null")) {
                nodes.add(null);
            } else {
                nodes.add(new TreeNode(Integer.parseInt(part)));
            }
        }

        Queue<TreeNode> queue = new LinkedList<>();
        TreeNode root = nodes.get(0);
        queue.offer(root);
        int index = 1;

        while (!queue.isEmpty() && index < nodes.size()) {
            TreeNode current = queue.poll();
            if (current != null) {
                if (index < nodes.size()) {
                    current.left = nodes.get(index++);
                    queue.offer(current.left);
                }
                if (index < nodes.size()) {
                    current.right = nodes.get(index++);
                    queue.offer(current.right);
                }
            }
        }

        return root;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();  // example: [1,2,2,3,3,null,null,4,4]

        TreeNode root = buildTreeFromLeetCodeInput(input);
        Solution sol = new Solution();
        boolean output = sol.isBalanced(root);

        System.out.println(output);
    }

}

##
mid11
import java.util.*;
public class Solution {
    public int deleteAndEarn(int[] nums) {
        if(nums.length==1) return nums[0];
        int[] h=new int[10001];
        for(int i=0;i<nums.length;i++){
            h[nums[i]]+=nums[i];
        }
        
        int p1=0,p2=0,b=0;
        for(int val:h){
            b=Math.max(p2,val+p1);
            p1=p2;
            p2=b;
        }
        return p1;
    }

    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution solution = new Solution();
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        int result = solution.deleteAndEarn(nums);
        System.out.println(result);
    }
}
##
hard11
import java.util.*;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) {
        val = x;
    }
}

public class Solution {
    //TYPE YOUR CODE HERE...
    int cnt=0;
    public int minCameraCover(TreeNode root){
        if(post(root)==0) return cnt+1;
        return cnt;
    }
    int post(TreeNode t){
        if(t==null) return 1;
        int l=post(t.left);
        int r=post(t.right);
        
        if(l==1&&r==1) return 0;
        else if(l==0 || r==0) {cnt++ ;return 2;}
        else return 1;
        
        
    }
    
    

    // Build tree from level order input
    public static TreeNode buildTree(String[] values) {
        if (values.length == 0 || values[0].equals("null")) return null;

        TreeNode root = new TreeNode(Integer.parseInt(values[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int i = 1;

        while (!queue.isEmpty() && i < values.length) {
            TreeNode current = queue.poll();
            if (!values[i].equals("null")) {
                current.left = new TreeNode(Integer.parseInt(values[i]));
                queue.offer(current.left);
            }
            i++;
            if (i < values.length && !values[i].equals("null")) {
                current.right = new TreeNode(Integer.parseInt(values[i]));
                queue.offer(current.right);
            }
            i++;
        }
        return root;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine(); // Read space-separated level-order input
        String[] values = line.trim().split("\\s+");

        TreeNode root = buildTree(values);
        Solution sol = new Solution();
        int result = sol.minCameraCover(root);
        System.out.println(result);
    }
}
##
easy12
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        // Both trees are empty
        if (p == null && q == null) return true;

        // One of the trees is empty
        if (p == null || q == null) return false;

        // Current values are different
        if (p.val != q.val) return false;

        // Recursively compare left and right subtrees
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
##
mid12
class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentPath = new ArrayList<>();
        dfs(root, targetSum, currentPath, result);
        return result;
    }

    private void dfs(TreeNode node, int targetSum, List<Integer> path, List<List<Integer>> result) {
        if (node == null) return;

        path.add(node.val);

        // Check if it's a leaf node and the path sum equals target
        if (node.left == null && node.right == null && targetSum == node.val) {
            result.add(new ArrayList<>(path));
        } else {
            // Recurse left and right
            dfs(node.left, targetSum - node.val, path, result);
            dfs(node.right, targetSum - node.val, path, result);
        }

        // Backtrack
        path.remove(path.size() - 1);
    }
}
##
hard12
public class Codec {
    static TreeNode node;

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        node=root;
        return "";
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        return node;
        
    }
}

##
easy13
public class Solution {
    public int islandPerimeter(int[][] grid) {
        int perimeter = 0;
        int rows = grid.length;
        int cols = grid[0].length;

        // Traverse each cell in the grid
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                // Check if the current cell is land
                if (grid[i][j] == 1) {
                    perimeter += 4;

                    // If the top neighbor is also land, subtract 2 (shared edge)
                    if (i > 0 && grid[i - 1][j] == 1) {
                        perimeter -= 2;
                    }

                    // If the left neighbor is also land, subtract 2 (shared edge)
                    if (j > 0 && grid[i][j - 1] == 1) {
                        perimeter -= 2;
                    }
                }
            }
        }

        return perimeter;
    }
}

##
mid13
class Solution {
    int pre=0;
    Map<Integer,Integer> mp=new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i=0;i<inorder.length;i++){
            mp.put(inorder[i],i);
        }
        return build(preorder,pre,inorder.length-1);
    }
    public TreeNode build(int[] preorder,int st,int end){
        if(st>end){
            return null;
        }
        int rootval=preorder[pre++];
        TreeNode root=new TreeNode(rootval);
        int ind=mp.get(rootval);
        root.left=build(preorder,st,ind-1);
        root.right=build(preorder,ind+1,end);
        return root;
    }

}
##
hard13

import java.util.*;

public class Solution {
    private List<List<Integer>> result = new ArrayList<>();
    private List<List<Integer>> graph = new ArrayList<>();
    private int[] discovery, low;
    private int time = 0;

    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {
        discovery = new int[n];
        low = new int[n];
        Arrays.fill(discovery, -1);

        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }

        for (List<Integer> conn : connections) {
            int u = conn.get(0), v = conn.get(1);
            graph.get(u).add(v);
            graph.get(v).add(u);
        }

        dfs(0, -1);
        return result;
    }

    private void dfs(int node, int parent) {
        discovery[node] = low[node] = time++;
        for (int neighbor : graph.get(node)) {
            if (neighbor == parent) continue;
            if (discovery[neighbor] == -1) {
                dfs(neighbor, node);
                low[node] = Math.min(low[node], low[neighbor]);
                if (low[neighbor] > discovery[node]) {
                    result.add(Arrays.asList(node, neighbor));
                }
            } else {
                low[node] = Math.min(low[node], discovery[neighbor]);
            }
        }
    }
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Solution sol = new Solution();

        int n = sc.nextInt(); // Number of nodes
        int m = sc.nextInt(); // Number of connections

        List<List<Integer>> connections = new ArrayList<>();

        for (int i = 0; i < m; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            connections.add(Arrays.asList(u, v));
        }

        List<List<Integer>> result = sol.criticalConnections(n, connections);
        for (List<Integer> edge : result) {
            System.out.println(edge.get(0) + " " + edge.get(1));
        }
    }
}


##
easy14
import java.util.Scanner;

public class Solution {
    public int addDigits(int num) {
        ///ADD YOUR CODE HERE
        while(num>9){
            int sum=0;
            while(num!=0){
                sum+=num%10;
                num/=10;
            }
            num=sum;
        }
        return num;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int num = scanner.nextInt();

        Solution solution = new Solution();
        int result = solution.addDigits(num);

        System.out.println(result);
    }
}
##
mid14
import java.util.Scanner;

// Main class with logic and main method
public class Solution {

    // Static nested class for ListNode
    static class ListNode {
        int val;
        ListNode next;
        ListNode(int x) {
            val = x;
            next = null;
        }
    }

    // Function to swap pairs
    public ListNode swapPairs(ListNode head) { 
        
        // Type your code here


        ListNode dummy = new ListNode(0);
        ListNode prev = dummy;
        dummy.next = head;

        while (head != null && head.next != null) {
            ListNode first = head;
            ListNode second = head.next;

            prev.next = second;
            first.next = second.next;
            second.next = first;

            prev = first;
            head = first.next;
        }
        return dummy.next;
 
        
    }

    // Create linked list from array
    public ListNode createList(int[] values) {
        if (values.length == 0) return null;

        ListNode head = new ListNode(values[0]);
        ListNode current = head;

        for (int i = 1; i < values.length; i++) {
            current.next = new ListNode(values[i]);
            current = current.next;
        }

        return head;
    }

    // Convert linked list to string in array format
    public String listToString(ListNode head) {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) sb.append(",");
            current = current.next;
        }
        sb.append("]");
        return sb.toString();
    }

    // Main method
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution solution = new Solution();

        //System.out.print("Enter number of elements in the list: ");
        int n = scanner.nextInt();

        int[] values = new int[n];
        //System.out.print("Enter the elements: ");
        for (int i = 0; i < n; i++) {
            values[i] = scanner.nextInt();
        }

        ListNode head = solution.createList(values);
        //System.out.println("Input: head = " + solution.listToString(head));

        ListNode swapped = solution.swapPairs(head);
        //System.out.println("Output: " + solution.listToString(swapped));
       System.out.println(solution.listToString(swapped));
        scanner.close();
    }
}
##
hard14
import java.util.*;

public class Solution {

    public int magnificentSets(int n, int[][] edges) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) graph.add(new ArrayList<>());
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }

        int[] colors = new int[n + 1];
        Arrays.fill(colors, -1);

        // Check if bipartite
        for (int i = 1; i <= n; i++) {
            if (colors[i] == -1 && !isBipartite(i, graph, colors)) return -1;
        }

        int res = 0;
        boolean[] visited = new boolean[n + 1];

        for (int i = 1; i <= n; i++) {
            if (visited[i]) continue;
            List<Integer> component = new ArrayList<>();
            dfs(i, graph, visited, component);

            int max = 0;
            for (int node : component) {
                max = Math.max(max, bfs(node, graph));
            }
            res += max;
        }
        return res;
    }

    private boolean isBipartite(int node, List<List<Integer>> graph, int[] colors) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(node);
        colors[node] = 0;

        while (!queue.isEmpty()) {
            int curr = queue.poll();
            for (int nei : graph.get(curr)) {
                if (colors[nei] == -1) {
                    colors[nei] = colors[curr] ^ 1;
                    queue.offer(nei);
                } else if (colors[nei] == colors[curr]) {
                    return false;
                }
            }
        }
        return true;
    }

    private void dfs(int node, List<List<Integer>> graph, boolean[] visited, List<Integer> component) {
        visited[node] = true;
        component.add(node);
        for (int nei : graph.get(node)) {
            if (!visited[nei]) dfs(nei, graph, visited, component);
        }
    }

    private int bfs(int start, List<List<Integer>> graph) {
        Queue<Integer> queue = new LinkedList<>();
        boolean[] visited = new boolean[graph.size()];
        queue.offer(start);
        visited[start] = true;

        int depth = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            depth++;
            for (int i = 0; i < size; i++) {
                int node = queue.poll();
                for (int nei : graph.get(node)) {
                    if (!visited[nei]) {
                        visited[nei] = true;
                        queue.offer(nei);
                    }
                }
            }
        }
        return depth;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        int n = scanner.nextInt();
        int m = scanner.nextInt();

        int[][] edges = new int[m][2];
        for (int i = 0; i < m; i++) {
            edges[i][0] = scanner.nextInt();
            edges[i][1] = scanner.nextInt();
        }

        int result = sol.magnificentSets(n, edges);
        System.out.println(result);

        scanner.close();
    }
}

##
hard14-opt2
import java.util.*;

class Solution {
    public int magnificentSets(int n, int[][] edges) {
        List<Integer>[] graph = new ArrayList[n + 1];
        for (int i = 0; i <= n; i++) graph[i] = new ArrayList<>();

        for (int[] e : edges) {
            graph[e[0]].add(e[1]);
            graph[e[1]].add(e[0]);
        }

        // Union-Find to group connected components
        int[] parent = new int[n + 1];
        for (int i = 1; i <= n; i++) parent[i] = i;

        for (int[] e : edges) {
            union(parent, e[0], e[1]);
        }

        // Check if the graph is bipartite
        int[] color = new int[n + 1];
        Arrays.fill(color, -1);
        for (int i = 1; i <= n; i++) {
            if (color[i] == -1 && !isBipartite(graph, color, i)) {
                return -1; // Not bipartite → impossible
            }
        }

        // Group nodes by components
        Map<Integer, List<Integer>> components = new HashMap<>();
        for (int i = 1; i <= n; i++) {
            int root = find(parent, i);
            components.computeIfAbsent(root, k -> new ArrayList<>()).add(i);
        }

        int result = 0;
        for (List<Integer> component : components.values()) {
            int maxDepth = 0;
            for (int node : component) {
                maxDepth = Math.max(maxDepth, bfsDepth(graph, node, n));
            }
            result += maxDepth;
        }

        return result;
    }

    // BFS to find the maximum number of levels (max group size starting from node)
    private int bfsDepth(List<Integer>[] graph, int start, int n) {
        boolean[] visited = new boolean[n + 1];
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        visited[start] = true;

        int level = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            level++;
            for (int i = 0; i < size; i++) {
                int node = queue.poll();
                for (int neighbor : graph[node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true;
                        queue.offer(neighbor);
                    }
                }
            }
        }

        return level;
    }

    // Check if graph is bipartite using BFS
    private boolean isBipartite(List<Integer>[] graph, int[] color, int start) {
        Queue<Integer> queue = new LinkedList<>();
        queue.offer(start);
        color[start] = 0;

        while (!queue.isEmpty()) {
            int u = queue.poll();
            for (int v : graph[u]) {
                if (color[v] == -1) {
                    color[v] = color[u] ^ 1;
                    queue.offer(v);
                } else if (color[v] == color[u]) {
                    return false; // Not bipartite
                }
            }
        }

        return true;
    }

    private int find(int[] parent, int u) {
        if (parent[u] != u) {
            parent[u] = find(parent, parent[u]);
        }
        return parent[u];
    }

    private void union(int[] parent, int u, int v) {
        parent[find(parent, u)] = find(parent, v);
    }
}
##

easy15
import java.util.Scanner;

public class Solution {
    public boolean isUgly(int n) {
        //Type Your code here
        while(n%2==0){
            n/=2;
        }
        while(n%3==0){
            n/=3;
        }
        while(n%5==0){
            n/=5;
        }
        return n==1;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        Scanner scanner = new Scanner(System.in);

        //System.out.print("Enter a number: ");
        if (scanner.hasNextInt()) {
            int n = scanner.nextInt();
            boolean result = solution.isUgly(n);
            System.out.println(result);
        }
        scanner.close();
    }
}
##
mid15
import java.util.*;

// Definition for singly-linked list
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

// Definition for a binary tree node
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

class Solution {
    TreeNode DFS(List<Integer> li, int st, int end){
        if(st>end){
            return null;
        }
        int mid=(st+end)/2;
        TreeNode root=new TreeNode(li.get(mid));
        root.left=DFS(li,st,mid-1);
        root.right=DFS(li,mid+1,end);
        return root;
    }
    public TreeNode sortedListToBST(ListNode head) {
        
        //Type Your Code Here
        List<Integer> li = new ArrayList<>();
        while(head!=null){
            li.add(head.val);
            head=head.next;
        }
        return DFS(li,0,li.size()-1);
        
    }
        
    
    public List<String> levelOrderWithNulls(TreeNode root) {
        List<String> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node == null) {
                result.add("null");
            } else {
                result.add(String.valueOf(node.val));
                queue.offer(node.left);
                queue.offer(node.right);
            }
        }

        
        int i = result.size() - 1;
        while (i >= 0 && result.get(i).equals("null")) {
            result.remove(i);
            i--;
        }

        return result;
    }
}

// Main class
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution solution = new Solution();

        //System.out.println("Input (e.g., [-10,-3,0,5,9]):");
        String input = scanner.nextLine().trim();

        input = input.replaceAll("[\\[\\]\\s]", "");
        String[] parts = input.split(",");

        // Build linked list
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        for (String part : parts) {
            if (!part.isEmpty()) {
                current.next = new ListNode(Integer.parseInt(part));
                current = current.next;
            }
        }

        TreeNode root = solution.sortedListToBST(dummy.next);
        List<String> output = solution.levelOrderWithNulls(root);

        //System.out.println("Output:");
        System.out.println(output);

        scanner.close();
    }
}
##
hard15
import java.util.*;

public class Solution {
    public int findShortestCycle(int n, int[][] edges) {
        List<List<Integer>> graph = new ArrayList<>();
        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }

        int shortest = Integer.MAX_VALUE;

        for (int i = 0; i < n; i++) {
            int[] dist = new int[n];
            Arrays.fill(dist, -1);
            int[] parent = new int[n];
            Arrays.fill(parent, -1);
            Queue<Integer> queue = new LinkedList<>();
            queue.offer(i);
            dist[i] = 0;

            while (!queue.isEmpty()) {
                int node = queue.poll();
                for (int nei : graph.get(node)) {
                    if (dist[nei] == -1) {
                        dist[nei] = dist[node] + 1;
                        parent[nei] = node;
                        queue.offer(nei);
                    } else if (parent[node] != nei) {
                        // Found a cycle
                        shortest = Math.min(shortest, dist[node] + dist[nei] + 1);
                    }
                }
            }
        }

        return shortest == Integer.MAX_VALUE ? -1 : shortest;
    }

        
        
        
        


    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Solution sol = new Solution();

        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] edges = new int[m][2];
        for (int i = 0; i < m; i++) {
            edges[i][0] = sc.nextInt();
            edges[i][1] = sc.nextInt();
        }

        int ans = sol.findShortestCycle(n, edges);
        System.out.println(ans);
    }
}

##


easy16
import java.util.Scanner;

public class Solution {
    public boolean isPalindrome(int x) {
        if(x<0) return false;
        int y=x;
        int sum=0;
        while(y!=0){
            sum=sum*10+y%10;
            y/=10;
        }
        return sum==x;
        // Type your code here
        
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        //System.out.print("Enter an integer: ");
        int number = scanner.nextInt();

        Solution solution = new Solution();
        if (solution.isPalindrome(number)) {
            System.out.println(number + " is a palindrome.");
        } else {
            System.out.println(number + " is not a palindrome.");
        }

        scanner.close();
    }
##
mid16


import java.util.HashMap;
import java.util.Scanner;

public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0;
        int sum = 0;

        HashMap<Integer, Integer> prefixSumFreq = new HashMap<>();
        prefixSumFreq.put(0, 1); // Initialize for sum = k at the beginning

        for (int num : nums) {
            sum += num;

            if (prefixSumFreq.containsKey(sum - k)) {
                count += prefixSumFreq.get(sum - k);
            }

            prefixSumFreq.put(sum, prefixSumFreq.getOrDefault(sum, 0) + 1);
        }

        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] nums = new int[n];

        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        int k = scanner.nextInt();

        Solution solution = new Solution();
        int result = solution.subarraySum(nums, k);
        System.out.println(result);

        scanner.close();
    }
}

##
hard16
import java.util.*;

public class prog {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = Integer.parseInt(sc.nextLine());
        String[] words = new String[n];
        for (int i = 0; i < n; i++) {
            words[i] = sc.nextLine();
        }

        List<List<Integer>> result = palindromePairs(words);
        for (List<Integer> pair : result) {
            System.out.print("[" + pair.get(0) + "," + pair.get(1) + "] ");
        }
        System.out.println();
    }

    public static List<List<Integer>> palindromePairs(String[] words) {
        List<List<Integer>> ans = new ArrayList<>();
        Map<String, Integer> map = new HashMap<>();

        for (int i = 0; i < words.length; ++i)
            map.put(new StringBuilder(words[i]).reverse().toString(), i);

        for (int i = 0; i < words.length; ++i) {
            final String word = words[i];
            if (map.containsKey("") && map.get("") != i && isPalindrome(word))
                ans.add(Arrays.asList(i, map.get("")));
            for (int j = 1; j <= word.length(); ++j) {
                final String l = word.substring(0, j);
                final String r = word.substring(j);
                if (map.containsKey(l) && map.get(l) != i && isPalindrome(r))
                    ans.add(Arrays.asList(i, map.get(l)));
                if (map.containsKey(r) && map.get(r) != i && isPalindrome(l))
                    ans.add(Arrays.asList(map.get(r), i));
            }
        }

        return ans;
    }

    private static boolean isPalindrome(final String word) {
        int l = 0;
        int r = word.length() - 1;
        while (l < r)
            if (word.charAt(l++) != word.charAt(r--))
                return false;
        return true;
    }
}

##

easy17
import java.util.Scanner;

public class Solution {

    public boolean threeConsecutiveOdds(int[] nums)
    {
        for(int i=0;i<nums.length-2;i++){
            if(nums[i]%2!=0 && nums[i+1]%2!=0 && nums[i+2]%2!=0){
                return true;
            }
        }
        return false;
        // Type Your Code Here 
        
        
        
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        int n = scanner.nextInt();

        int[] arr = new int[n];
        
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        boolean result = sol.threeConsecutiveOdds(arr);
        System.out.println(result);

        scanner.close();
    }
}
##
mid17

import java.util.*;

public class Solution {

    public int networkDelayTime(int[][] times, int n, int k) {
        List<List<int[]>> graph = new ArrayList<>();
        
        // Build adjacency list
        for (int i = 0; i <= n; i++) graph.add(new ArrayList<>());
        for (int[] time : times) {
            graph.get(time[0]).add(new int[]{time[1], time[2]});
        }

        // Dijkstra's algorithm
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]); // [node, time]
        pq.offer(new int[]{k, 0});
        int[] dist = new int[n + 1];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[k] = 0;

        while (!pq.isEmpty()) {
            int[] curr = pq.poll();
            int node = curr[0], time = curr[1];

            for (int[] neighbor : graph.get(node)) {
                int next = neighbor[0], edgeTime = neighbor[1];
                if (time + edgeTime < dist[next]) {
                    dist[next] = time + edgeTime;
                    pq.offer(new int[]{next, dist[next]});
                }
            }
        }

        int max = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] == Integer.MAX_VALUE) return -1;
            max = Math.max(max, dist[i]);
        }

        return max;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        // Read number of edges
        int m = scanner.nextInt();
        int[][] times = new int[m][3];

        // Read edges
        for (int i = 0; i < m; i++) {
            times[i][0] = scanner.nextInt();
            times[i][1] = scanner.nextInt();
            times[i][2] = scanner.nextInt();
        }

        // Read number of nodes and starting node
        int n = scanner.nextInt();
        int k = scanner.nextInt();

        int result = sol.networkDelayTime(times, n, k);
        System.out.println(result);
    }
}

##
easy18
import java.util.Scanner;
class GuessGame {
    int pick;
    public GuessGame(int pick) {
        this.pick = pick;
    }

    public int guess(int num) {
        if (num == pick) return 0;
        else if (num > pick) return -1;
        else return 1;
    }
}

public class Solution extends GuessGame {

    public Solution(int pick) {
        super(pick);
    }

    public int guessNumber(int n) 
    {
        int left =0;
        int right=n;
        while(left<right){
            int mid = (right+left)/2;
            
            if(mid==pick) return pick;
            else if(mid>pick) left=mid+1;
            else right=mid-1;
        }
        return pick;
     // Type Your Code Here 
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int pick = scanner.nextInt();
        Solution solution = new Solution(pick);
        int result = solution.guessNumber(n);
        System.out.println( result);
        scanner.close();
    }
}
##
hard17

import java.util.*;

public class Solution {
   
    int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};
    int m, n;

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0) return 0;
        m = matrix.length;
        n = matrix[0].length;
        int[][] memo = new int[m][n];
        int max = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                max = Math.max(max, dfs(matrix, i, j, memo));
            }
        }
        return max;
    }

    private int dfs(int[][] matrix, int i, int j, int[][] memo) {
        if (memo[i][j] != 0) return memo[i][j];

        int max = 1;
        for (int[] dir : dirs) {
            int x = i + dir[0];
            int y = j + dir[1];
            if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {
                max = Math.max(max, 1 + dfs(matrix, x, y, memo));
            }
        }

        memo[i][j] = max;
        return max;
    }

    
    public static void main(String[] args) 
    {
        Scanner sc = new Scanner(System.in);
        int m = sc.nextInt();
        int n = sc.nextInt();
        int[][] matrix = new int[m][n];
        for (int i = 0; i < m; i++)
            for (int j = 0; j < n; j++)
                matrix[i][j] = sc.nextInt();
        Solution sol = new Solution();
        System.out.println(sol.longestIncreasingPath(matrix));
        sc.close();
    }
}



##
mid18
import java.util.*;

public class Solution {

    public boolean isBipartite(int[][] graph) 
    {
       int color[] = new int[graph.length];
       Arrays.fill(color,-1);
       for(int i=0;i<graph.length;i++){
           if(color[i]==-1){
               if(DFS(i,0, color, graph)==false){
                   return false;
               }
           }
       }
       return true;
    }
    boolean DFS(int node,int col, int[] color, int[][] graph){
        color[node]=col;
        for(int i:graph[node]){
            if(color[i]==col){
                return false;
            }
            if(color[i]==-1){
                if(DFS(i,1-col, color, graph)==false) return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        int n = scanner.nextInt(); // number of nodes
        int[][] graph = new int[n][];

        for (int i = 0; i < n; i++) {
            int m = scanner.nextInt(); // number of neighbors
            graph[i] = new int[m];
            for (int j = 0; j < m; j++) {
                graph[i][j] = scanner.nextInt();
            }
        }

        boolean result = sol.isBipartite(graph);
        System.out.println(result);

        scanner.close();
    }
}


}
##
hard18
import java.util.*;

public class Solution {

    public int minCost(int n, int[] cuts) {
        int c = cuts.length;
        int[] allCuts = new int[c + 2];
        allCuts[0] = 0;
        allCuts[c + 1] = n;
        Arrays.sort(cuts);
        for (int i = 0; i < c; i++) {
            allCuts[i + 1] = cuts[i];
        }

        int[][] dp = new int[c + 2][c + 2];

        for (int len = 2; len <= c + 1; len++) {
            for (int i = 0; i + len <= c + 1; i++) {
                int j = i + len;
                dp[i][j] = Integer.MAX_VALUE;
                for (int k = i + 1; k < j; k++) {
                    int cost = allCuts[j] - allCuts[i] + dp[i][k] + dp[k][j];
                    dp[i][j] = Math.min(dp[i][j], cost);
                }
            }
        }

        return dp[0][c + 1];
    }



    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        try {
            // First line: read stick length
            int n = Integer.parseInt(scanner.nextLine().trim());

            // Second line: read space-separated cuts
            String[] parts = scanner.nextLine().trim().split("\\s+");
            int[] cuts = new int[parts.length];
            for (int i = 0; i < parts.length; i++) {
                cuts[i] = Integer.parseInt(parts[i]);
            }

            Solution sol = new Solution();
            int result = sol.minCost(n, cuts);
            System.out.println(result);

        } catch (Exception e) {
            System.out.println("Invalid input format.");
        } finally {
            scanner.close();
        }
    }
}

##

summa

venna
##



